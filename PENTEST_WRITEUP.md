# Testing the vulnerable app

so i built this intentionally broken flask app to practice. this writeup is basically my notes from testing it with the port scanner and trying some basic attacks.

## Setup

run it:
```bash
cd demo_app
python vulnerable_app.py
```

runs on localhost:5000, uses sqlite

## Finding it

first i used my port scanner to see what's open:

```bash
go run port_scanner.go -host localhost -start 5000 -end 5100
```

found:
```
Port 5000: OPEN - http (HTTP/1.1)
  Banner: Werkzeug/2.3.0 Python/3.x
```

ok so it's flask/werkzeug. good start

## SQL injection on the login form

the login at `/login` doesn't sanitize inputs at all lol

the vulnerable line:
```python
cursor.execute(f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'")
```

yeah... string concatenation directly into SQL. classic mistake

### how i exploited it

payload:
```
username: admin' OR '1'='1' --
password: literally anything
```

what happens:
```sql
SELECT * FROM users WHERE username = 'admin' OR '1'='1' --' AND password = 'anything'
```

the `'1'='1'` is always true, and `--` comments out the rest. bypasses auth completely.

worked on first try:
```
Login successful! Welcome, admin
```

## other stuff i found

### `/users` endpoint leak

this endpoint just returns EVERYTHING with no auth check:

```bash
curl http://localhost:5000/users
```

response:
```json
[
  {"id": 1, "username": "admin", "password": "admin123"},
  {"id": 2, "username": "user", "password": "pass123"}
]
```

passwords in plaintext too... yikes

### other vulns
- no CSRF tokens anywhere
- no rate limiting (could bruteforce easily)
- passwords stored as plaintext
- debug mode enabled (stack traces show code)

## impact

basically:
- **critical**: can bypass login with basic SQL injection
- **high**: full user database exposed including passwords
- **medium**: CSRF possible on all forms

## how to fix

1. use parameterized queries:
```python
cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password))
```

2. hash passwords:
```python
import bcrypt
hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
```

3. add auth to `/users`
4. add CSRF protection
5. rate limiting
6. turn off debug in prod

## notes

this was helpful for learning. key things:
- never concatenate user input into SQL
- always sanitize/validate inputs  
- parameterized queries are your friend
- SQL injection is still super common (OWASP top 10)

the port scanner's banner grabbing helped identify the tech stack before i started testing which was nice
